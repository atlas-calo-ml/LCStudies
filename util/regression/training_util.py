import os, pickle, pathlib
import pandas as pd
from keras.wrappers.scikit_learn import KerasRegressor
from tensorflow.keras.models import load_model

# Given sets of input a model filename,
# train a single model.
# Suffix is used in practice to label as "charged" or "neutral" regression,
# whereas model_key is used to distinguish type/architecture.
def TrainNetwork(regressor, modelfile, x_train, y_train, x_valid, y_valid, sample_weight, callbacks, overwriteModel=False, finishTraining=True):
    model_dir = '/'.join(modelfile.split('/')[:-1])
    try: os.makedirs(model_dir)
    except: pass
    model_filename = modelfile
    
    # Check if the model exists -- and load it if not overwriting.
    initial_epoch = 0
    if(pathlib.Path(model_filename).exists() and not overwriteModel):
        regressor.model = load_model(model_filename)
        
        # Now we want to figure out for how many epochs the loaded model was already trained,
        # so that it's trained, in total, for the requested number of epochs.
        # keras models don't seem to hold on to an epoch attribute for whatever reason,
        # so we will figure out the current epoch based on CSVLogger output if it exists.
        history_filename = '.'.join(model_filename.split('.')[:-1]) + '.csv'
        if(pathlib.Path(history_filename).exists()):            
            with open(history_filename) as f:
                for i,l in enumerate(f):
                    pass
                initial_epoch = i # zero-indexing will take care of the 1st line, which has headers
        if(not finishTraining): initial_epoch = regressor.get_params()['epochs']
        regressor.set_params(initial_epoch=initial_epoch)
        
#         # We also want to get information on the number of iterations our model as undergone so far.
#         # This is useful if the model is implementing a learning rate decay (via the optimizer's "decay" argument),
#         # which is a function of the iteration (not the epoch). We haven't saved the decay -- we'll assume the user
#         # has not changed it since last training -- but we want to get the iterations so that it's not zero.
#         iterations = 0
#         if(pathlib.Path(history_filename).exists()):
#             df = pd.read_csv(history_filename)
#             iterations = df['iterations'].to_numpy()[-1]
#         print('Iterations: {}'.format(regressor.model.optimizer._iterations))
        
    history = regressor.fit(
        x=x_train,
        y=y_train,
        validation_data=(
            x_valid,
            y_valid
        ),
        sample_weight=sample_weight,
        callbacks=callbacks
    )
    
    # TODO: Load history from the history file -- this will contain the full history of the network,
    # not just whatever was generated by the most recent training session. This is useful
    # if training is interrupted & restarted.
    history=history.history
    
    saveModel = True
    if(initial_epoch >= regressor.get_params()['epochs']): saveModel = False # no new training was done
    
    if(saveModel):
        #if(regressor.get_params()['epochs'] != regressor.get_params()['initial_epoch']):
        print('  Saving model to {}.'.format(model_filename))
        regressor.model.save(model_filename)
    return history